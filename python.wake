##########################################################
#
# Python-Wake
#
# Supports Python virtual environments through the "pipenv" mechanism,
#   and provides a simplified "runPython" function to invoke a python module.
#
# To support distinct environments, the .venv directory is located in the
#   same directory as Pipfile. It is installed automatically by wake,
#   but the installation can be performed ahead of time by other tools (eg wit).
#
# Note we only look at "Pipfile.lock".  This routine does NOT update or create "Pipfile.lock".
############################################################

# README. Encountered problems using Fuse with pipenv. While not fully diagnosed,
#   pipenv creates symbol


#######################################################################################
# Create a python command line based on the module name. Adds cmd line options as needed.
######################################################################################
global def pythonCommand module args = ("python3", "-m", module, args)



######################################################
# Add a Python virtual environment to a plan.
#   Currently only supports pipenv, but this is where would examine the directory
#   to see if other env managers are being used.
######################################################
global def addPythonEnv = addPipenvEnv
global def installPythonEnv = installPipenvEnv


##########################################################
# Add a pipenv virtual environment to the plan.
##########################################################
def addPipenvEnv pipDir plan =

    # Install the virtual environment if not already done
    def installed = installPipenvEnv pipDir
    def venv = "build/{pipDir}/.venv"

    # Add the binary directory to PATH.
    plan
    | editPlanVisible (installed ++ _)
    | addPlanPath  "PYTHONPATH"  venv
    | addPlanPath  "PATH" "{venv}/bin"


##############################################################################
# Install the pipenv environment associated with Pipfile.lock.
#   The .venv will reside in the same directory as the Pipfile.lock.
#   We do NOT look at Pipfile, nor do we update Pipfile.lock. We simply create a reproducible set of packages..
################################################################################
global def installPipenvEnv pipDir =

   # Step 1 - Copy the Pipfile.lock to the build directory. Pipfile is just along for the ride.
   def pipFile = installIn "build" (source "{pipDir}/Pipfile")
   def lock = installIn "build" (source "{pipDir}/Pipfile.lock") | debug "Lock"

   # Step 2 - Running from the build direcgory, use pip to install pipenv in .venv/bin
   def pipOutputs =
      makeSystemPlan ("pip3", "install", "--target=.venv", "pipenv", Nil) (pipFile, lock, Nil)
      | setPlanResources ("python/python/3.7.1", Nil)
      | planSetDirectory "build/{pipDir}"
      | runJob
      | getJobOutputs| debug "outputs"

   # Step 3 - use pipenv and Pipfile.lock to install everything else in .venv.
   def pipenvOutputs =
     makeSystemPlan (".venv/bin/pipenv",  "sync", "--dev", Nil) (pipFile, lock, pipOutputs)
     | setPlanResources ("python/python/3.7.1", Nil)
     | setPlanVar "PIPENV_VENV_IN_PROJECT" "YES"
     | planChdir "build/{pipDir}" Nil
     | runJob
     | getJobOutputs

   # Our return value is all of the files installed. (potential dependencies to downstream jobs)
   pipenvOutputs ++ pipOutputs


global def testPython Unit = # Why doesn't this work?
    makeSystemPlan ("python3", "-v", Nil) Nil
    | addPythonEnv "{here}/tests"
    | runJob | getJobStdout
