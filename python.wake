############################################################################
#
# Python-Wake
#
# Supports multiple Python virtual environments through the "pipenv" mechanism.
#   Each environment corresponds to a directory containing a Pipfile.
#
# To use the python a virtual environment, add it to the command's plan
#     makePlan  cmd  visible
#     | addPythonEnv  "directory containing Pipfile"
#     | runJob
#
# If you wish to have the python modules downloaded by tne "preinstall" function.
#      publish preinstall = (pythonInstaller "directory-containing-Pipfile"), Nil
#
#############################################################################



######################################################
# Add a Python virtual environment to a plan.
#   Currently only supports pipenv, but this is where would examine the directory
#   to see if other env managers are being used.
##########################################################
global def addPythonEnv pipDir plan =

    # Install the virtual environment if not already done
    def installed = installPipenvEnv pipDir
    def venv = "build/{pipDir}/.venv"

    # Add the binary directory to PATH.
    plan
    | editPlanVisible (installed ++ _)
    | addPlanPath  "PYTHONPATH"  venv
    | addPlanPath  "PATH" "{venv}/bin"


###########################################################################
# Create an installer function which, when invoked, installs python virtual env.
#    Note the extra "_" in the argument list
##########################################################################
global def pythonInstaller pipdir _ =
  installPipenvEnv pipdir | verifyFiles



#######################################################################################
# Create a python command line based on the module name. Adds cmd line options as needed.
######################################################################################
global def pythonCommand module args = ("python3", "-m", module, args)



##############################################################################
# Install the python environment associated with Pipfile.lock.
#  Note we install pipenv first, then use pipenv to install the remaining modules.
#     For the workaround, the first step returns one file, and the second step
#     returns all the files except that one.
#     Appended together, we have a complete set of files.
################################################################################
target installPipenvEnv pipDir =

   # Where we will install the virtual environment.
   def venv = "build/{pipDir}/.venv"

   # Step 1 - Copy Pipfile.lock to the build directory. Pipfile is just along for the ride.
   def pipFile = installIn "build" (source "{pipDir}/Pipfile")
   def lock = installIn "build" (source "{pipDir}/Pipfile.lock")

   # Step 2 - Running from the build directory, use pip to install pipenv in .venv/bin
   def pipOutputs =
      makePlan ("pip3", "install", "--target=.venv", "pipenv", Nil) (pipFile, lock, Nil)
      | setPlanLocalOnly True   # TODO: Remove when wake problem is fixed.
      | setPlanFnOutputs (\_ venv, Nil)  # TODO: Remove when wake problem is fixed.
      | setPlanResources ("python/python/3.7.1", Nil)
      | setPlanDirectory "build/{pipDir}"
      | runJob
      | getJobOutputs

   # Step 3 - use pipenv and Pipfile.lock to install everything else in .venv.
   def pipenvOutputs =
     makePlan (".venv/bin/pipenv",  "sync", "--dev", Nil) (pipFile, lock, pipOutputs)
     | setPlanLocalOnly True       # TODO: remove when wake problem is resolved
     | setPlanFnOutputs ( \_ remove venv (files venv `.*`) ) # TODO: remove when wake problem is resolved
     | setPlanResources ("python/python/3.7.1", Nil)
     | setPlanVar "PIPENV_VENV_IN_PROJECT" "YES"
     | setPlanDirectory "build/{pipDir}"
     | runJob
     | getJobOutputs

   # Our return value is all of the files installed.
   pipenvOutputs ++ pipOutputs


global def testPython Unit =
    makeSystemPlan ("python3", "-v", Nil) Nil
    | addPythonEnv "{here}/tests"
    | runJob | getJobStdout


# Remove a string from a list of strings.
def remove string strings =
    filter (_ !=~ string) strings
